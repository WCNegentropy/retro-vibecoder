/**
 * ORM Models Enrichment Strategy
 *
 * Generates ORM model definitions with real fields and relationships
 * based on the database and ORM in the stack.
 */

import type {
  EnrichmentStrategy,
  TechStack,
  EnrichmentFlags,
  EnrichmentContext,
} from '../../../types.js';

function generatePrismaSchema(modelName: string): string {
  const modelLower = modelName.toLowerCase();
  return `// Prisma schema â€” ${modelName} model
// Generated by UPG Enrichment Engine

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model ${modelName} {
  id        String   @id @default(cuid())
  name      String
  email     String?  @unique
  active    Boolean  @default(true)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("${modelLower}s")
}
`;
}

function generateDrizzleSchema(modelName: string): string {
  const modelLower = modelName.toLowerCase();
  return `import { pgTable, text, boolean, timestamp } from 'drizzle-orm/pg-core';
import { createId } from '@paralleldrive/cuid2';

export const ${modelLower}s = pgTable('${modelLower}s', {
  id: text('id').primaryKey().$defaultFn(() => createId()),
  name: text('name').notNull(),
  email: text('email').unique(),
  active: boolean('active').default(true).notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export type ${modelName} = typeof ${modelLower}s.$inferSelect;
export type New${modelName} = typeof ${modelLower}s.$inferInsert;
`;
}

function generateSqlAlchemyModel(modelName: string): string {
  const modelLower = modelName.toLowerCase();
  return `"""${modelName} model definition."""

from datetime import datetime
from sqlalchemy import Column, String, Boolean, DateTime
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()


class ${modelName}(Base):
    """${modelName} database model."""

    __tablename__ = "${modelLower}s"

    id = Column(String, primary_key=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, nullable=True)
    active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    def __repr__(self) -> str:
        return f"<${modelName}(id={self.id!r}, name={self.name!r})>"

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "name": self.name,
            "email": self.email,
            "active": self.active,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
`;
}

function generateGormModel(modelName: string): string {
  return `package models

import (
\t"time"

\t"gorm.io/gorm"
)

// ${modelName} represents a ${modelName.toLowerCase()} in the database.
type ${modelName} struct {
\tID        string         \`json:"id" gorm:"primaryKey"\`
\tName      string         \`json:"name" gorm:"not null"\`
\tEmail     *string        \`json:"email,omitempty" gorm:"uniqueIndex"\`
\tActive    bool           \`json:"active" gorm:"default:true"\`
\tCreatedAt time.Time      \`json:"created_at"\`
\tUpdatedAt time.Time      \`json:"updated_at"\`
\tDeletedAt gorm.DeletedAt \`json:"-" gorm:"index"\`
}

// TableName overrides the default table name.
func (${modelName}) TableName() string {
\treturn "${modelName.toLowerCase()}s"
}
`;
}

function generateDieselModel(modelName: string): string {
  const modelLower = modelName.toLowerCase();
  return `use chrono::NaiveDateTime;
use diesel::prelude::*;
use serde::{Deserialize, Serialize};

/// Database schema for ${modelLower}s table
diesel::table! {
    ${modelLower}s (id) {
        id -> Text,
        name -> Text,
        email -> Nullable<Text>,
        active -> Bool,
        created_at -> Timestamp,
        updated_at -> Timestamp,
    }
}

/// ${modelName} model for database queries
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Selectable)]
#[diesel(table_name = ${modelLower}s)]
pub struct ${modelName} {
    pub id: String,
    pub name: String,
    pub email: Option<String>,
    pub active: bool,
    pub created_at: NaiveDateTime,
    pub updated_at: NaiveDateTime,
}

/// Insertable ${modelName} for creating new records
#[derive(Debug, Deserialize, Insertable)]
#[diesel(table_name = ${modelLower}s)]
pub struct New${modelName} {
    pub id: String,
    pub name: String,
    pub email: Option<String>,
}
`;
}

export const ModelsEnrichStrategy: EnrichmentStrategy = {
  id: 'enrich-models',
  name: 'ORM Model Definitions',
  priority: 18, // Before API routes

  matches: (stack: TechStack, flags: EnrichmentFlags) =>
    flags.fillLogic && stack.database !== 'none' && stack.orm !== 'none',

  apply: async (context: EnrichmentContext) => {
    const { files, stack, rng } = context;
    const modelNames = ['User', 'Item', 'Post', 'Task', 'Product'];
    const modelName = rng.pick(modelNames);

    switch (stack.orm) {
      case 'prisma':
        if (!context.introspect.hasFile('prisma/schema.prisma')) {
          files['prisma/schema.prisma'] = generatePrismaSchema(modelName);
        }
        break;
      case 'drizzle':
        files['src/db/schema.ts'] = generateDrizzleSchema(modelName);
        break;
      case 'sqlalchemy':
        files['src/models.py'] = generateSqlAlchemyModel(modelName);
        break;
      case 'gorm':
        files['internal/models/models.go'] = generateGormModel(modelName);
        break;
      case 'diesel':
        files['src/models.rs'] = generateDieselModel(modelName);
        break;
    }
  },
};
