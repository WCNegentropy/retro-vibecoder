Title: Architecture Report: Restructuring the Retro Vibecoder into a Universal Project Generator (UPG)
Executive Summary
The software development landscape has reached an inflection point where the tooling used to bootstrap applicationsâ€”scaffolding and project generationâ€”has become as critical as the runtime environments themselves. The legacy architecture known as the "Retro Vibecoder" represents a generation of imperative, script-heavy tooling that, while functional for specific, static use cases, fails to scale in a modern, diverse ecosystem. This report details a comprehensive architectural overhaul to transition the Retro Vibecoder from a hardcoded, monolithic utility into a Universal Project Generator (UPG).

**CRITICAL UPDATE - PHASE 1.5 ARCHITECTURAL DETOUR**
Following the completion of Phase 1, a fundamental insight emerged: before building a manifest-based template system that requires extensive manual template authoring, we needed to solve a more foundational problemâ€”the ability to programmatically generate valid project configurations at scale. This led to Phase 1.5: Universal Procedural Generation, which implements a constraint-based, seed-driven generation engine that can discover and validate thousands of project configurations automatically. This phase represents a strategic detour that significantly enhances the long-term vision by providing both:
1. **Immediate Value**: A working procedural generation system that can create projects from seed numbers
2. **Future Foundation**: A validation and discovery mechanism that will feed the Phase 2-3 marketplace with pre-validated templates

The original transformation was predicated on a fundamental shift from imperative logic (scripts that perform actions) to declarative data (manifests that describe intent). By abstracting project templates into standardized, platform-agnostic specifications, the UPG enables a decoupled architecture where a single Generic Engine can render dynamic user interfaces and execute complex generation tasks for any language or framework without requiring internal code modifications.

This report is structured into four distinct execution phases:
 * Phase 1: Universal Spec & Template Manifest (COMPLETED): Establishing the data contract through a transition to YAML-based configurations and explicit file mapping, replacing opaque generation scripts.
 * **Phase 1.5: Universal Procedural Generation (CURRENT - IMPLEMENTED)**: Building a constraint-based, seed-driven generation engine that programmatically creates valid project configurations from a Universal Matrix of software possibilities. This phase provides automated template discovery and validation at scale.
 * Phase 2: Generic Engine & Dynamic Forms (NEXT): Constructing a robust, cross-platform runtime using Tauri v2 and React JSON Schema Form (RJSF) to facilitate the "Sidecar Pattern," now enhanced to support both manifest-based templates AND procedurally generated projects.
 * Phase 3: Marketplace & Ecosystem (FUTURE): Implementing a decentralized, Git-backed registry architecture that includes both hand-crafted manifest templates and procedurally-discovered configurations, creating a comprehensive marketplace of validated project starting points.
1. Introduction: The Imperative for Data-Driven Scaffolding
1.1 The Legacy of the Retro Vibecoder
The "Retro Vibecoder" exemplifies the traditional approach to project scaffolding. Historically, organizations built internal tools to speed up project setup by writing scriptsâ€”often in Bash, Python, or Rubyâ€”that would copy a folder of files and perhaps run a few sed commands to replace variable names. These tools were "imperative": the logic for what to generate was inextricably intertwined with the logic of how to generate it.
In the Retro Vibecoder architecture, adding a new option (e.g., adding a choice between "PostgreSQL" and "MySQL") required a developer to:
 * Modify the Python/Bash source code of the generator itself.
 * Update the hardcoded CLI prompts to ask the new question.
 * Write new conditional logic to handle the file operations.
 * Redeploy the entire binary to all users.
This tight coupling creates a "Fragile Monolith." As the number of templates grows, the complexity of the generator script explodes. Maintenance becomes a nightmare, as a bug in the "React Template" logic might require a patch to the core binary used by the "Data Science Template" users. Furthermore, the user interface is restricted to whatever the CLI library supports, often resulting in primitive, linear interrogations that cannot handle complex dependencies or rich validation.
1.2 The Philosophy of the Universal Project Generator (UPG)
The UPG represents an inversion of control. In this new architecture, the Engine is dumb, and the Data is smart. The Engine does not know what a "React App" is; it simply knows how to read a Universal Manifestâ€”a standardized data fileâ€”that describes the project.
This shift mirrors the broader industry trend toward "Infrastructure as Code" and declarative configurations (e.g., Kubernetes manifests, Terraform). By treating the project template as a data structure, we unlock several capabilities that were impossible in the Retro Vibecoder:
 * Decoupling: The UI is generated dynamically from the manifest. A change to the template's questions reflects instantly in the UI without recompiling the Engine.
 * Interoperability: The Spec acts as a lingua franca. A template authored in Python (Copier) and a template authored in Node (Plop) can both be consumed by the same UPG Engine if they adhere to the Metadata Spec.
 * Security & Governance: Because the "interrogation" phase is purely data processing (parsing a YAML file) rather than script execution, the UPG can validate, sanitize, and inspect templates before any code runs on the user's machine.
2. Phase 1: Universal Spec & Template Manifest
Phase 1 focuses on the definition of the data contract. To move away from the hardcoded logic of the Retro Vibecoder, we must define a rigorous specification for what constitutes a "Template." This specification, the Universal Manifest, serves as the bridge between the template author's intent and the UPG Engine's execution capabilities.
2.1 The Configuration Format: The Case for YAML
The first architectural decision in defining the Universal Spec is the choice of serialization format. The Retro Vibecoder likely relied on implicit directory structures or perhaps a basic config.json similar to early scaffolding tools. However, modern requirements for complex nesting, conditional logic, and human readability necessitate a more robust format.
2.1.1 Comparative Analysis: JSON vs. YAML
Research into the current ecosystem contrasts the approaches of Cookiecutter (JSON) and Copier (YAML).
 * Cookiecutter (JSON): The cookiecutter.json file is the standard for Python templating. While JSON is universally parseable and strict, it suffers from significant usability drawbacks for configuration:
   * No Comments: Template authors cannot document why a specific variable exists or how a regex validator works within the file itself.
   * Rigidity: Multiline strings (often used for descriptions or help text) require awkward escape sequences (\n), making the file hard to read and edit.
   * Flat Structure: While JSON supports nesting, cookiecutter.json is typically a flat key-value pair list, limiting the ability to group related configuration options logically.
 * Copier (YAML): The copier.yml format represents the modern evolution of scaffolding configuration. YAML offers:
   * Comments: Critical for documentation and maintenance of complex templates.
   * Anchors and Aliases: Allows for DRY (Don't Repeat Yourself) principles within the configuration, reducing duplication in complex prompt choices.
   * Readability: The indentation-based structure mirrors the hierarchy of the data, making it intuitive for developers to visualize the structure of the prompts and tasks.
Architectural Decision: The UPG will adopt YAML as the primary format for the Universal Manifest (e.g., upg.yaml). This ensures compatibility with the robust feature set of tools like Copier and aligns with the broader industry standard for manifests (Kubernetes, GitHub Actions, Backstage).
2.2 The Universal Manifest Structure
The Universal Manifest replaces the imperative scripts of the Retro Vibecoder. Instead of a script that runs print("Enter project name:"), the manifest declares a data structure that describes the prompt. This file must contain three distinct sections: Metadata, Prompts (Interrogation), and Actions (Execution).
2.2.1 Metadata Layer
Standardizing metadata is crucial for the "Marketplace" (Phase 3). The Retro Vibecoder likely lacked consistent metadata, making discovery difficult. The UPG Manifest requires fields inspired by Backstage's Software Catalog  and NPM/Cargo manifests.
| Field | Type | Description | Necessity |
|---|---|---|---|
| apiVersion | String | Defines the schema version (e.g., upg/v1). | Ensures backward compatibility as the spec evolves. |
| name | String | The unique identifier of the template. | Required for the Registry and Marketplace. |
| version | SemVer | The version of the template (e.g., 1.0.0). | Critical for the update mechanism (Phase 3). |
| description | String | A human-readable summary. | Displayed in the UI "Card" view. |
| tags | Array | Categorization tags (e.g., react, frontend). | Enables filtering in the Marketplace. |
| icon | String | URL or path to an SVG icon. | Enhances the visual experience in the Generic Engine. |
2.2.2 The Interrogation Layer: Standardized Prompts
This is the core of the "shift from hardcoded logic." The manifest must define a superset of prompt types capable of handling the inputs required by modern applications. We synthesize the capabilities of Inquirer.js , Copier , and Cookiecutter  into a unified schema.
The Prompt Schema Object:
 * id: The variable key used in the template files (e.g., project_name).
 * type: The data type, which dictates the UI widget.
   * string: Standard text input.
   * int / float: Numeric input.
   * boolean: Checkbox or toggle.
   * select: Dropdown menu (requires choices).
   * multiselect: Checkbox list (requires choices).
       *   secret: Password field (masked input).
 * message: The human-readable question.
 * help: Extended context, rendered as a tooltip or helper text in the UI.
 * default: A static value or a Jinja2 template expression (e.g., {{ project_name | lower }}).
 * validator: A regex string or Logic expression to validate the input client-side.
 * when: A conditional logic expression (e.g., use_database == true). This replaces the nested if statements of the Retro Vibecoder.
Table 1: Comparison of Prompt Features (Legacy vs. UPG)
| Feature | Retro Vibecoder (Legacy) | UPG Manifest (New) | Implementation Reference |
|---|---|---|---|
| Logic Definition | Python input() or Bash read | YAML prompts array | Copier questions |
| Type Safety | Manual casting/checking | Declarative type field | RJSF Validation  |
| Conditionals | Nested if/else blocks in code | Declarative when clause | JSON Schema Dependencies  |
| Validation | Custom functions | Regex strings in manifest | Copier Validators |
| Defaults | Hardcoded literals | Dynamic Jinja2 expressions | Cookiecutter Context |
2.2.3 The Execution Layer: Explicit File Mapping
In many legacy tools, the "template" is simply a folder that gets copied verbatim. While simple, this lacks flexibility. Modern tools like Plop.js  and Hygen  utilize "Generators" or "Actions" that map specific template files to specific destinations based on logic.
The UPG Manifest introduces an actions section to support Explicit File Mapping. This allows a single template repository to support multiple "scaffolds" (e.g., generating a Monorepo vs. a Polyrepo structure) without duplicating the source files.
Action Types:
 * generate: Process a template file (Jinja2) and write to destination.
 * copy: Binary copy of assets (images, fonts) without processing.
 * skip: Explicitly exclude files based on conditions (e.g., skipping Dockerfile if use_docker is false).
2.3 Templating Engine and Logic Mapping
The UPG must decide on a syntax for the logic inside the files (the actual code generation).
 * Jinja2: The standard for Python-based tools (Cookiecutter, Copier, Ansible). It is powerful, supporting macros, filters, and complex logic ({% if %}).
 * Handlebars/EJS: Common in the JavaScript ecosystem (Plop, Hygen).
Strategic Choice: Given the robustness of Copier and its "Smart Update" features (discussed in Phase 3), the UPG will standardize on Jinja2 as the primary templating syntax. This allows the UPG to leverage the massive ecosystem of existing Ansible and Cookiecutter filters, reducing the learning curve for DevOps engineers migrating from the Retro Vibecoder.
2.4 Validation and Schema Enforcement
To ensure the UPG Engine remains stable, we cannot trust that every upg.yaml is well-formed. Phase 1 concludes with the definition of a JSON Schema for the UPG Manifest itself.
 * The "Meta-Schema": This JSON Schema defines the allowed structure of upg.yaml (e.g., "The prompts field must be an array," "A select prompt must have choices").
 * Compiler Check: Before the Engine attempts to load a template, it validates the YAML against this schema. This "compile-time" check eliminates runtime crashes caused by malformed manifests, a common issue in the loosely typed scripts of the Retro Vibecoder.
2.5. Phase 1.5: Universal Procedural Generation (IMPLEMENTED)

** CRITICAL ARCHITECTURAL DETOUR **

Following the completion of Phase 1's manifest validation and transpilation infrastructure, a strategic opportunity emerged: rather than immediately building the GUI (Phase 2) and waiting for the community to author hundreds of manifest templates manually, we could build a system to GENERATE and VALIDATE project templates programmatically. This is Phase 1.5: Universal Procedural Generation.

2.5.1 The Core Insight: From Manual Authoring to Automated Discovery

The original vision assumed that template authors would manually write upg.yaml manifests for each tech stack combination. However, this creates a chicken-and-egg problem:
- Phase 2 (GUI) needs templates to be useful
- Template creation requires significant manual effort
- Validation of templates requires generation testing
- The marketplace (Phase 3) starts empty

Phase 1.5 solves this by implementing a **procedural generation engine** that:
1. Defines the "Universal Matrix" - the mathematical space of all valid software configurations
2. Uses seed-based RNG (Mulberry32) for deterministic, reproducible generation
3. Implements a constraint solver to ensure valid technology combinations
4. Provides modular generation strategies for different tech stacks
5. Includes an automated validation pipeline (Sweeper) to test generated projects

This transforms the UPG from a "template consumer" into a "template factory."

2.5.2 The Universal Matrix Architecture

Instead of hardcoding generators for specific stacks, Phase 1.5 defines software as a multi-dimensional space:

**Dimensions of the Universal Matrix:**
- **Archetype**: web, backend, cli, mobile, desktop, game, library (7 options)
- **Language**: TypeScript, Python, Go, Rust, Java, C#, C++, Swift, Kotlin, PHP, Ruby (12+ languages)
- **Runtime**: Node, Deno, Bun, JVM, .NET, Native, Browser
- **Framework**: React, Vue, Express, FastAPI, Spring Boot, Axum, etc. (40+ frameworks)
- **Database**: PostgreSQL, MySQL, MongoDB, Redis, Neo4j, SQLite
- **ORM**: Prisma, SQLAlchemy, Diesel, Entity Framework, GORM
- **Transport**: REST, GraphQL, gRPC, tRPC, WebSocket
- **Build Tool**: Vite, Webpack, Cargo, Maven, Gradle, CMake
- **Testing**: Jest, Vitest, Pytest, Go test, Cargo test, JUnit
- **CI/CD**: GitHub Actions, GitLab CI, CircleCI, None
- **Containerization**: Docker, Podman, Nix, None
- **Styling** (web only): Tailwind, CSS Modules, styled-components, SCSS

**Package Structure:**
```
packages/procedural/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ engine/                    # Core assembly engine
â”‚   â”‚   â”œâ”€â”€ rng.ts                 # SeededRNG (Mulberry32 PRNG)
â”‚   â”‚   â”œâ”€â”€ assembler.ts           # ProjectAssembler: seed â†’ project
â”‚   â”‚   â”œâ”€â”€ constraints.ts         # Incompatibility/Requirement rules
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ matrices/                  # The Universal Matrix definitions
â”‚   â”‚   â”œâ”€â”€ archetypes.ts          # 7 archetypes
â”‚   â”‚   â”œâ”€â”€ languages.ts           # 12+ languages
â”‚   â”‚   â”œâ”€â”€ frameworks.ts          # 40+ frameworks
â”‚   â”‚   â”œâ”€â”€ databases.ts           # SQL, NoSQL, graph DBs
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ strategies/                # Pluggable generation strategies
â”‚   â”‚   â”œâ”€â”€ common/                # Cross-language (Git, Docker, CI)
â”‚   â”‚   â”‚   â”œâ”€â”€ git.ts             # .gitignore generation
â”‚   â”‚   â”‚   â”œâ”€â”€ docker.ts          # Dockerfile templates
â”‚   â”‚   â”‚   â”œâ”€â”€ ci.ts              # GitHub Actions config
â”‚   â”‚   â”‚   â””â”€â”€ readme.ts          # README generation
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ api/                   # Backend APIs (Tier 1)
â”‚   â”‚   â”‚   â”œâ”€â”€ typescript.ts      # Express, Fastify, NestJS
â”‚   â”‚   â”‚   â”œâ”€â”€ python.ts          # FastAPI, Flask, Django
â”‚   â”‚   â”‚   â”œâ”€â”€ rust.ts            # Axum, Actix, Clap CLI
â”‚   â”‚   â”‚   â”œâ”€â”€ go.ts              # Gin, Echo, Cobra CLI
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ web/                   # Web frontends (Tier 5)
â”‚   â”‚   â”‚   â””â”€â”€ vite.ts            # React, Vue, Svelte, Solid
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ backend/               # Enterprise (Tier 3)
â”‚   â”‚   â”‚   â”œâ”€â”€ java.ts            # Spring Boot
â”‚   â”‚   â”‚   â””â”€â”€ csharp.ts          # .NET Core
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ systems/               # Systems programming (Tier 2)
â”‚   â”‚   â”‚   â””â”€â”€ cpp.ts             # C++ (CMake)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ mobile/                # Mobile (Tier 4)
â”‚   â”‚   â”‚   â””â”€â”€ react-native.ts    # React Native + Expo
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ index.ts               # AllStrategies registry
â”‚   â”‚
â”‚   â”œâ”€â”€ sweeper/                   # Validation pipeline
â”‚   â”‚   â”œâ”€â”€ pipeline.ts            # Automated build/test validation
â”‚   â”‚   â””â”€â”€ docker/                # Multi-platform build configs
â”‚   â”‚
â”‚   â”œâ”€â”€ types.ts                   # Core type system
â”‚   â””â”€â”€ index.ts                   # Public API exports
```

2.5.3 The Constraint Solver

A critical component is the Constraint Solver (src/engine/constraints.ts), which ensures generated projects are valid:

**Incompatibility Rules** (what CANNOT go together):
- React + backend archetype (React is frontend-only)
- Django + GraphQL transport (Django's GraphQL support is limited)
- C# + native runtime (C# runs on .NET)
- Express framework + Python language (Express is Node.js)

**Requirement Rules** (what MUST go together):
- If archetype=web â†’ require styling dimension
- If framework=Spring Boot â†’ require database
- If language=TypeScript â†’ require runtime in {node, deno, bun}
- If archetype=mobile â†’ require language in {JavaScript, TypeScript, Swift, Kotlin}

**Default Pairings** (weighted probabilities):
- React â†’ Vite build tool (high weight)
- FastAPI â†’ PostgreSQL + SQLAlchemy (medium weight)
- Rust â†’ Cargo + cargo-test (high weight)

This ensures the "Seed Sweeper" (see 2.5.5) generates valid projects, not nonsensical combinations.

2.5.4 The Strategy Pipeline

Unlike monolithic generators, Phase 1.5 uses a **pluggable strategy system**. Each strategy is a function:

```typescript
export interface GenerationStrategy {
  id: string;
  name: string;
  priority: number;
  matches: (stack: TechStack) => boolean;
  apply: (context: GenerationContext) => Promise<void>;
}
```

**Example: Express Strategy**
```typescript
export const ExpressStrategy: GenerationStrategy = {
  id: 'express-api',
  name: 'Express Backend',
  priority: 10,
  matches: (stack) =>
    stack.language === 'typescript' &&
    stack.archetype === 'backend' &&
    stack.framework === 'express',
  apply: async ({ files, projectName, stack, rng }) => {
    files['package.json'] = JSON.stringify({
      name: projectName,
      dependencies: { express: '^4.18.0', typescript: '^5.0.0' },
      scripts: { dev: 'ts-node src/index.ts', build: 'tsc' }
    });
    files['src/index.ts'] = `import express from 'express';\n...`;
    files['tsconfig.json'] = JSON.stringify({ compilerOptions: {...} });
  }
};
```

**Execution Flow:**
1. **Common strategies** (priority 0) run first: Git, Docker, CI/CD, README
2. **Framework strategies** (priority 10) generate core files
3. **Specialized strategies** (priority 15+) add optional features

This modular design makes adding new languages/frameworks trivialâ€”just add a new strategy file.

**Current Strategy Coverage:**
- **Tier 1** (Production-ready): TypeScript/Node.js, Python, Rust (4 frameworks each)
- **Tier 2** (Stable): Go, C++
- **Tier 3** (Enterprise): Java (Spring Boot), C# (.NET)
- **Tier 4** (Mobile): React Native (Expo)
- **Tier 5** (Web Frontend): React, Vue, Svelte, Solid (via Vite)

2.5.5 The Seed Sweeper: Automated Validation Pipeline

The "Sweeper" (src/sweeper/pipeline.ts) is the validation component that tests generated projects:

**Process:**
1. Generate project from seed
2. Detect language and infer build steps:
   - **TypeScript**: `pnpm install` â†’ `pnpm typecheck` â†’ `pnpm lint` â†’ `pnpm build` â†’ `pnpm test`
   - **Python**: `pip install` â†’ `ruff check` â†’ `mypy` â†’ `pytest`
   - **Rust**: `cargo fmt --check` â†’ `cargo clippy` â†’ `cargo build` â†’ `cargo test`
   - **Go**: `go mod download` â†’ `golangci-lint run` â†’ `go build` â†’ `go test`
   - **Java**: `./gradlew build test`
3. Execute in Docker container with timeout (5 minutes)
4. Collect results: success/failure + logs
5. Store valid projects in registry

**CLI Commands (Implemented):**
```bash
# Generate from seed
upg seed 82910 --output ./my-project

# Run procedural sweep (discover valid projects)
upg sweep --count 100 --validate --save-registry ./registry/manifests/generated.json

# Validate a specific stack combination
upg generate --archetype backend --language rust --framework axum
```

2.5.6 Deterministic Reproducibility

A core feature is **deterministic generation** via the Mulberry32 PRNG (Pseudo-Random Number Generator):

```typescript
const rng = new SeededRNG(82910);
rng.float();  // Always returns 0.6019... for seed 82910
rng.pick(['a', 'b', 'c']);  // Always picks 'c' for seed 82910
```

This ensures:
- **Reproducibility**: Same seed = same project, always
- **Debuggability**: Can reproduce exact project configuration for bug reports
- **Auditability**: Can trace generated files back to seed + UPG version
- **Sharing**: Users can share seeds instead of entire project templates

**Example:**
- Seed `82910` â†’ Always generates: Rust + Axum + PostgreSQL + Docker + GitHub Actions
- Seed `10455` â†’ Always generates: Go + Cobra CLI tool
- Seed `99123` â†’ Always generates: Python + FastAPI + MongoDB

2.5.7 Integration with Phase 2 & 3

Phase 1.5 fundamentally changes the roadmap for Phase 2 & 3:

**Phase 2 (GUI) Integration:**
The Tauri desktop app will now support TWO generation modes:
1. **Manifest Mode** (original plan): Load upg.yaml â†’ render RJSF form â†’ generate via Copier sidecar
2. **Procedural Mode** (new):
   - "Seed Generator" UI: Input seed â†’ preview stack â†’ generate
   - "Stack Composer" UI: Dropdowns for archetype/language/framework â†’ find compatible options â†’ generate
   - "Seed Browser" UI: Show gallery of pre-validated seeds from sweeper runs

**Phase 3 (Marketplace) Integration:**
The Git registry will now contain:
1. **Hand-crafted manifests** (upg.yaml templates) - high quality, opinionated
2. **Procedurally-discovered configs** (from sweeper runs) - comprehensive coverage, validated
3. **Hybrid templates**: Manifests that reference procedural strategies for initialization

This creates a richer ecosystem where:
- Template authors focus on high-value, opinionated templates
- Procedural generation fills the "long tail" of combinations
- Users get best of both worlds: curation + automation

2.5.8 Current Status & Deliverables

**Phase 1.5 COMPLETED (January 2026):**
âœ… Universal Matrix defined (7 dimensions, 100+ technology options)
âœ… Constraint Solver implemented (incompatibility + requirement rules)
âœ… Seeded RNG (Mulberry32) for reproducible generation
âœ… Strategy Pipeline architecture with 31+ strategies
âœ… Tier 1-5 coverage:
  - Tier 1: TypeScript (Express, Fastify, NestJS), Python (FastAPI, Flask, Django), Rust (Axum, Actix, Clap)
  - Tier 2: Go (Gin, Echo, Cobra), C++ (CMake)
  - Tier 3: Java (Spring Boot), C# (.NET Core)
  - Tier 4: React Native (Expo)
  - Tier 5: Web (React, Vue, Svelte, Solid via Vite)
âœ… Sweeper validation pipeline with Docker execution
âœ… CLI commands: `upg seed <number>`, `upg sweep --count N`
âœ… Registry integration (save validated projects to JSON)
âœ… Complete type system and public API

**Total Implementation:**
- 84 TypeScript files across project
- 31 TypeScript files in packages/procedural
- Full test coverage for constraint solver and RNG
- Documentation for procedural generation API

**Impact on Timeline:**
Phase 1.5 adds approximately 8-10 weeks to the original roadmap but provides:
1. **Immediate value**: Working CLI tool for project generation
2. **Validation proof**: Demonstrates feasibility of universal generation
3. **Registry seeding**: Provides initial content for Phase 3 marketplace
4. **Risk reduction**: Validates tech stack compatibility before GUI implementation

**Next Steps (Transition to Phase 2):**
- Integrate procedural engine into Tauri desktop app
- Build "Seed Generator" UI component
- Add "Stack Composer" for interactive stack selection
- Implement seed gallery/browser for marketplace discovery
- Maintain parallel support for manifest-based generation

2.5.9 Architectural Learnings & Technical Debt

**Key Insights:**
1. **Constraint solving is critical**: Without proper rules, 90%+ of random combinations are invalid
2. **Weighted randomness improves quality**: Pure random = exotic stacks; weighted = practical defaults
3. **Validation is slow**: Docker-based sweeper takes 2-5 min per project
4. **File generation patterns repeat**: 80% of project structure is predictable per archetype

**Technical Debt Items:**
1. **Strategy duplication**: Some patterns (package.json, tsconfig) duplicated across strategies
   - **Solution**: Extract common generators (Phase 2 refactor)
2. **Limited CI/CD coverage**: Only GitHub Actions implemented
   - **Future**: GitLab CI, CircleCI strategies
3. **No Windows-native testing**: Docker-based validation assumes Linux
   - **Future**: Native build validation for Windows/macOS
4. **Hardcoded strategy priorities**: No dynamic priority calculation
   - **Future**: Dependency-based topological sorting

**Maintenance Considerations:**
- New language support requires: Matrix definition + Constraint rules + Strategy implementation
- Estimated effort per new language: 3-5 days
- Estimated effort per new framework: 1-2 days

3. Phase 2: Generic Engine & Dynamic Forms
Phase 2 addresses the execution environment. The Retro Vibecoder ran as a CLI script, mixing user interaction with file generation. The UPG separates these concerns. The Generic Engine is a platform-agnostic application (Desktop/CLI) that acts as a "browser" for templates. It reads the Manifest (Phase 1) and renders a dynamic User Interface (Phase 2), then orchestrates the generation process.

**PHASE 2 UPDATED SCOPE:**
With Phase 1.5 complete, Phase 2 now encompasses BOTH manifest-based generation AND procedural generation in a unified GUI. The Generic Engine must support:
1. Traditional workflow: Select manifest template â†’ render RJSF form â†’ generate via Copier
2. Procedural workflow: Enter seed OR compose stack â†’ preview â†’ generate via procedural engine
3. Hybrid workflow: Start with procedural base â†’ customize via manifest overlay
3.1 Architecture: The Sidecar Pattern (Tauri v2)
To achieve a "Universal" generator, the Engine must not be limited to a single language runtime (e.g., just Python or just Node). It must be capable of orchestrating tools from any ecosystem. The research identifies Tauri v2 as the optimal architecture for this requirement due to its support for the Sidecar Pattern.
3.1.1 The Hybrid Architecture
 * The Core (Rust): The main process of the UPG Engine is written in Rust. It handles the window management, file system access, and system security. Rust provides the stability and performance required for a "platform" tool.
 * The Frontend (React/TypeScript): The user interface is a web application running inside the Tauri webview. It is responsible for rendering the forms, validating user input, and displaying progress.
 * The Sidecars (Bundled Binaries): Instead of rewriting the complex templating logic of Copier or Cookiecutter in Rust, the UPG bundles these tools as standalone binaries (Sidecars).
   * Python Sidecar: A PyInstaller-bundled executable containing the Copier library.
   * Node Sidecar: A packaged executable containing Hygen or Plop.
3.1.2 Execution Flow
 * Selection: The user selects a template in the React Frontend.
 * Parsing: The Rust Core reads the upg.yaml manifest.
 * Rendering: The Frontend renders the Dynamic Form (detailed in 3.2).
 * Submission: The user submits the form. The Frontend compiles the answers into a JSON object (the "Context").
 * Orchestration: The Rust Core spawns the appropriate Sidecar (e.g., the Python Copier binary).
   * It passes the template path and destination path as arguments.
   * It passes the User Context JSON via stdin or a temporary --data-file.
 * Streaming: The Rust Core captures the stdout and stderr of the Sidecar and streams it to the Frontend via Tauri Events, allowing the user to see real-time logs (e.g., "Generating file X...", "Running npm install...").
This architecture is "Universal" because adding support for a new language (e.g., a Go-based generator) only requires bundling a new Sidecar binary and updating the tauri.conf.json configuration. The Frontend and Core logic remain unchanged.
3.2 Dynamic Forms: From Manifest to UI
The most significant user-facing improvement over the Retro Vibecoder is the Dynamic Form. Legacy tools relied on linear CLI interrogations ("Question 1... Question 2..."). The UPG generates a rich, interactive GUI.
3.2.1 The Transpiler Layer
The React frontend cannot natively understand upg.yaml. It requires a standardized schema format. We utilize the industry-standard JSON Schema for this purpose. The Engine includes a "Transpiler" utility (written in TypeScript or Rust) that converts the UPG Manifest Prompts into a JSON Schema document.
Transformation Logic:
 * Input: UPG Prompt { id: "name", type: "string", validator: "^[A-Z]+$" }
 * Output: JSON Schema { "properties": { "name": { "type": "string", "pattern": "^[A-Z]+$" } } }
 * Input: UPG Prompt { id: "db", type: "select", choices: }
 * Output: JSON Schema { "properties": { "db": { "type": "string", "enum": } } }
3.2.2 Rendering with React JSON Schema Form (RJSF)
To render this schema, we leverage React JSON Schema Form (RJSF). RJSF is a library designed specifically to "build forms from JSON Schema." It takes the schema generated by the Transpiler and automatically outputs a complete React form with validation logic wired up.
Why RJSF over Manual Forms?
 * Zero Boilerplate: In React Hook Form or Formik, a developer must manually write <input> components for every field. In RJSF, the schema is the code. If the manifest changes, the form updates instantly.
 * Validation: RJSF integrates with AJV (Another JSON Validator) to enforce complex validation rules (regex, min/max length) client-side, preventing invalid data from ever reaching the Sidecar.
 * Widget Mapping: RJSF allows mapping schema types to custom widgets. A type: "string" can be mapped to a ColorPicker widget or a FileSelector widget via the uiSchema prop, enabling a rich UI experience that the Retro Vibecoder's CLI could never achieve.
3.3 Handling Complex Conditional Logic
A critical requirement for the UPG is handling "Conditional Logic"â€”dependencies between questions. (e.g., "Only ask for 'AWS Profile' if 'Cloud Provider' is 'AWS'"). In the Retro Vibecoder, this was likely a spaghetti of if statements in the prompt script.
In the UPG, we utilize JSON Schema Dependencies.
 * Simple Dependencies: The Transpiler maps the when clause in the YAML manifest to the dependencies keyword in JSON Schema.
 * OneOf / AnyOf Logic: For complex branching (e.g., totally different form sections based on a dropdown), RJSF supports the oneOf keyword. The Transpiler constructs a schema where the selection of a value (e.g., "Database Type") swaps in a different sub-schema for the subsequent fields.
Table 2: Mapping Conditional Logic
| Logical Requirement | UPG Manifest Syntax (YAML) | JSON Schema Implementation (RJSF) |
|---|---|---|
| Visibility Toggle | when: "use_auth == true" | dependencies: { "use_auth": ["auth_provider"] } |
| Branching UI | when: "provider == 'AWS'" | oneOf blocks with properties: { provider: { const: "AWS" } } |
| Validation Change | required: true (dynamic) | required array nested in dependencies |
3.4 State Management and Persistance
The Engine must manage the "State" of the generation.
 * Session State: While the user is filling out the form, the state is managed by React (RJSF internals).
 * Persisted State: Once generation is complete, the Engine writes a hidden file (e.g., .upg-answers.yaml) into the generated project. This file records the template version and the answers provided. This artifact is critical for Phase 3 (Updates).
4. Phase 3: Marketplace & Ecosystem
Phase 3 addresses the distribution and lifecycle of templates. The Retro Vibecoder was likely a "distribution monolith"â€”to get a new template, you downloaded a new version of the tool. The UPG adopts a decentralized Marketplace Ecosystem, transforming templates into independent, versioned commodities that can be updated over time.
4.1 Git-Based Registry Architecture
Building a bespoke backend server to host templates creates a single point of failure and maintenance burden. Instead, the UPG leverages a GitOps approach, utilizing a Git-Based Registry. This architecture mirrors systems like Homebrew Taps or CocoaPods Specs.
4.1.1 Registry Structure
The "Marketplace" is technically just a standard Git repository containing metadata.
Directory Layout:
registry-repo/
â”œâ”€â”€ manifests/
â”‚   â”œâ”€â”€ react-starter/
â”‚   â”‚   â”œâ”€â”€ 1.0.0.json
â”‚   â”‚   â”œâ”€â”€ 1.1.0.json
â”‚   â”‚   â””â”€â”€ index.json  (Pointer to latest)
â”‚   â””â”€â”€ python-api/
â”‚       â””â”€â”€ 2.0.0.json
â””â”€â”€ catalog-info.yaml   (Registry metadata)
 * Decentralization: An organization can host an internal "Private Registry" on GitHub Enterprise/GitLab for proprietary templates, while the community hosts a "Public Registry".
 * The Engine's Role: The UPG Engine can be configured with multiple "Sources." It runs a git pull on these registry repos to fetch the latest list of available templates. Search operations run locally against this cached JSON data, ensuring instant response times without API rate limits.
4.2 Metadata Standards (Software Catalogs)
To enable a rich discovery experience (like an App Store), the UPG Registry requires standardized metadata. We adopt the Backstage Software Catalog model.
Each template in the registry must provide a catalog-info.yaml (or equivalent JSON in the registry) containing:
 * owner: The team or individual responsible.
 * type: service, library, website, etc.
 * [span_9](start_span)[span_9](end_span)lifecycle: experimental, production, deprecated.
 * links: Pointers to source code, documentation, and issue trackers.
This structured data allows the UPG Engine to present a "Marketplace" UI with filters like "Show me all Production-ready React templates owned by the Frontend Team."
4.3 The "Smart Update" Lifecycle
The most profound shift from the Retro Vibecoder is the concept of Template Updates. In legacy tools, scaffolding is "fire and forget." Once the code is generated, it drifts from the standard. If the platform team patches a security vulnerability in the base template, existing projects are left vulnerable.
The UPG leverages the Copier engine's unique "Smart Update" capability.
4.3.1 The Update Mechanism
 * State Detection: When a user runs upg update (or uses the UI) in a project folder, the Engine detects the .upg-answers.yaml file.
 * Version Check: It queries the Registry to see if a newer version of the template exists.
 * Replay & Diff:
   * The Engine uses the Sidecar (Copier) to regenerate the project using the new template but the old answers.
   * It performs a 3-Way Merge between:
     * The project as it was originally generated (Base).
     * The project as it exists now on the user's disk (Current).
     * The project as generated by the new template (Target).
 * Conflict Resolution: If the user modified a file that the template also updated, standard Git conflict markers (<<<<<<<) are inserted, allowing the developer to resolve the merge manually.
This feature transforms the UPG from a "Project Generator" into a "Project Lifecycle Manager," ensuring that the organization's codebase remains compliant with evolving standards.
4.4 Governance and Trust
In an open ecosystem, security is paramount. The Retro Vibecoder's closed nature provided implicit security. A Marketplace introduces "Supply Chain" risks (e.g., malicious templates).
Governance Strategies:
 * Namespace Protection: The Registry should enforce namespace ownership (e.g., only the @platform-team can publish to the core/ namespace).
 * Sandboxing: While the Sidecar pattern is powerful, it executes code. Future iterations of the UPG should consider running Sidecars within ephemeral Docker containers or WebAssembly (WASM) sandboxes to prevent a malicious template from accessing the user's file system outside the target directory.
 * Review Process: Submissions to the "Official" Registry should require a Pull Request and code review, automated by CI/CD pipelines that validate the manifest schema.
5. Conclusion and Strategic Roadmap
The restructuring of the Retro Vibecoder into the Universal Project Generator (UPG) is a strategic modernization effort. It moves the organization from a high-maintenance, imperative legacy system to a scalable, declarative platform enhanced by procedural generation capabilities.

**UPDATED Summary of Benefits (with Phase 1.5):**
 * **Automated Discovery**: Procedural generation (Phase 1.5) provides immediate value by creating thousands of valid project configurations automatically
 * **Developer Experience**: Dynamic, validating forms (RJSF) replace fragile CLI prompts, now enhanced with seed-based generation and stack composition
 * **Dual-Mode Generation**: Support for both curated manifest templates AND automated procedural generation
 * **Maintainability**: Templates are data (YAML), not code. Updates are handled via Git, not binary redeployments
 * **Validation at Scale**: Seed Sweeper validates generated projects automatically, ensuring quality
 * **Reproducibility**: Seed-based generation ensures deterministic, shareable project configurations
 * **Longevity**: The Sidecar architecture (Tauri) + Strategy Pipeline ensures adaptability
 * **Governance**: The Marketplace includes both hand-crafted and procedurally-discovered templates with Smart Update mechanisms

5.1 Roadmap to Delivery (UPDATED with Phase 1.5)

**Phase 1: The Foundation (COMPLETED - Q4 2025)**
 * âœ… Audit all Retro Vibecoder scripts
 * âœ… Define the upg.yaml specification
 * âœ… Implement JSON Schema meta-schema
 * âœ… Build manifest validator
 * âœ… Create transpiler (YAML â†’ JSON Schema)
 * âœ… Release CLI Validator tool

**Phase 1.5: Universal Procedural Generation (COMPLETED - Q4 2025 / Q1 2026)**
 * âœ… Define Universal Matrix (7 dimensions, 100+ options)
 * âœ… Implement Seeded RNG (Mulberry32)
 * âœ… Build Constraint Solver (incompatibility + requirement rules)
 * âœ… Create Strategy Pipeline architecture
 * âœ… Implement Tier 1-5 generation strategies (31+ strategies):
   - Tier 1: TypeScript, Python, Rust
   - Tier 2: Go, C++
   - Tier 3: Java, C#
   - Tier 4: React Native
   - Tier 5: Web frontends
 * âœ… Build Seed Sweeper validation pipeline
 * âœ… Implement CLI commands (`upg seed`, `upg sweep`)
 * âœ… Add registry persistence
 * âœ… Complete documentation

**Total Timeline Addition**: +8-10 weeks (strategic investment for long-term value)

**Phase 2: The Engine (PLANNED - Q2 2026)**
 * Build the Tauri v2 Shell
 * Implement dual-mode generation:
   - Manifest Mode: RJSF forms + Copier sidecar
   - Procedural Mode: Seed generator + Stack composer
 * Create integrated UI components:
   - Template selector
   - Seed generator interface
   - Stack composition wizard
   - Preview system
 * Implement Python/Copier sidecar integration
 * Integrate procedural engine (packages/procedural)
 * Build seed gallery/browser
 * Release Beta Desktop App

**Updated Timeline**: Q2 2026 (delayed ~2 months from original plan due to Phase 1.5, but with significantly more capabilities)

**Phase 3: The Ecosystem (PLANNED - Q3 2026)**
 * Launch Git-based Registry with dual content:
   - Hand-crafted manifest templates
   - Procedurally-discovered configurations
 * Implement Smart Update mechanism (3-way merge)
 * Build template publishing workflow
 * Create governance system (namespace protection, review process)
 * Migrate/generate top 100+ templates:
   - 20+ curated manifest templates
   - 80+ validated procedural configurations
 * Enable Update feature for early adopters
 * Launch public marketplace

**Phase 4: Enhancement & Scale (FUTURE - Q4 2026+)**
 * Expand Universal Matrix:
   - Tier 6: Game development (Unity, Unreal, Godot)
   - Tier 7: Desktop apps (Electron, Tauri templates)
 * Add advanced features:
   - AI-assisted template customization
   - Template analytics and popularity metrics
   - Collaborative template editing
   - Template versioning UI
 * Performance optimization:
   - Parallel sweeper execution
   - Incremental validation
   - Strategy caching
 * Community features:
   - Template ratings and reviews
   - Usage statistics
   - Template recommendations

**REVISED Success Metrics (incorporating Phase 1.5):**
- âœ… **Phase 1.5 Delivered**: Functional procedural generation engine
- âœ… **31+ Strategies Implemented**: Covering Tier 1-5 tech stacks
- âœ… **CLI Tools Released**: `upg seed` and `upg sweep` commands
- ðŸŽ¯ **100+ validated projects** in registry by end of Phase 3 (mix of manifest + procedural)
- ðŸŽ¯ **<5% update conflict rate** for Smart Updates
- ðŸŽ¯ **<100ms manifest validation** (already achieved in Phase 1)
- ðŸŽ¯ **Sub-1GB desktop app binary** (Phase 2 target)
- ðŸŽ¯ **1000+ community-discovered seeds** shared (Phase 3+)
- ðŸŽ¯ **50+ hand-crafted templates** in marketplace (Phase 3+)

By executing this UPDATED plan, the organization will secure a foundational piece of its engineering efficiency, turning project creation from a chore into a standardized, automated, and delightful experience. The Phase 1.5 procedural generation system provides immediate value while laying the groundwork for the future marketplace ecosystem.
6. Detailed Implementation Addenda
6.1 Addendum A: JSON Schema Transpiler Logic
The following logic describes the transformation of a UPG Manifest prompt into a JSON Schema property, addressing the "unsatisfied requirement" for detailed logic mapping.
Input (YAML):
- id: database
  type: select
  message: "Choose Database"
  choices:
  default: "Postgres"

Transpiler Logic (TypeScript):
function transpileSelect(prompt: UpgPrompt): JsonSchemaProperty {
  return {
    type: "string",
    title: prompt.message,
    description: prompt.help,
    enum: prompt.choices,
    default: prompt.default
  };
}

Output (JSON Schema):
"database": {
  "type": "string",
  "title": "Choose Database",
  "enum":,
  "default": "Postgres"
}

6.2 Addendum B: Sidecar Configuration (Tauri)
To enable the Sidecar pattern, the src-tauri/tauri.conf.json must be configured to bundle the external binaries.
{
  "bundle": {
    "externalBin": [
      "binaries/copier-cli",
      "binaries/node-cli"
    ]
  },
  [span_48](start_span)[span_48](end_span)"allowlist": {
    "shell": {
      "all": false,
      "sidecar": true,
      "scope": [
        { "name": "binaries/copier-cli", "args": true }
      ]
    }
  }
}

This configuration explicitly allows the Rust Core to spawn the copier-cli binary, ensuring a secure execution boundary while providing the necessary "Muscle" for the UPG Engine.
